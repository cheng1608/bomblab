0000000000401010 <func4>:
  401010:       41 54                   push   %r12                 ; 保存寄存器 r12
  401012:       55                      push   %rbp                 ; 保存寄存器 rbp
  401013:       53                      push   %rbx                 ; 保存寄存器 rbx
  401014:       89 fb                   mov    %edi,%ebx            ; 将参数 edi 复制到 ebx =5
  401016:       85 ff                   test   %edi,%edi            ; 测试 edi 是否为 0
  401018:       7e 24                   jle    40103e <func4+0x2e> ; 如果小于等于零，则跳转到 func4 结尾
  40101a:       89 f5                   mov    %esi,%ebp            ; 将参数 esi 复制到 ebp 
  40101c:       89 f0                   mov    %esi,%eax            ; 将参数 esi 复制到 eax 
  40101e:       83 ff 01                cmp    $0x1,%edi            ; 比较 edi 是否为 1
  401021:       74 20                   je     401043 <func4+0x33> ; 如果是，则跳转到 func4 结尾
  401023:       8d 7f ff                lea    -0x1(%rdi),%edi      ; edi 减一
  401026:       e8 e5 ff ff ff          callq  401010 <func4>       ; 递归调用 func4
  40102b:       44 8d 24 28             lea    (%rax,%rbp,1),%r12d ; r12 = rax + rbp
  40102f:       8d 7b fe                lea    -0x2(%rbx),%edi     ; edi = ebx - 2
  401032:       89 ee                   mov    %ebp,%esi            ; 将 ebp 复制到 esi
  401034:       e8 d7 ff ff ff          callq  401010 <func4>       ; 递归调用 func4
  401039:       44 01 e0                add    %r12d,%eax           ; eax += r12
  40103c:       eb 05                   jmp    401043 <func4+0x33> ; 跳转到 func4 结尾
  40103e:       b8 00 00 00 00          mov    $0x0,%eax            ; 如果输入参数为 0，则返回 0
  401043:       5b                      pop    %rbx                 ; 恢复寄存器 rbx
  401044:       5d                      pop    %rbp                 ; 恢复寄存器 rbp
  401045:       41 5c                   pop    %r12                 ; 恢复寄存器 r12
  401047:       c3                      retq                        ; 返回

int f(x, y){
    if (x == 0) return 0;
    if (x == 1) return y;
    return f(x-1,y) + f(x-2,y) + y;
}

0000000000401048 <phase_4>:
  401048:       48 83 ec 18             sub    $0x18,%rsp           ; 分配 24 字节的栈空间
  40104c:       48 8d 4c 24 0c          lea    0xc(%rsp),%rcx      ; rcx = 第二个数
  401051:       48 8d 54 24 08          lea    0x8(%rsp),%rdx      ; rdx = 第一个数
  401056:       be 01 28 40 00          mov    $0x402801,%esi      ; esi = 0x402801
  40105b:       b8 00 00 00 00          mov    $0x0,%eax           ; eax = 0
  401060:       e8 cb fb ff ff          callq  400c30 <__isoc99_sscanf@plt> ; 调用 scanf 函数
  401065:       83 f8 02                cmp    $0x2,%eax           ; 比较返回值是否为 2
  401068:       75 0c                   jne    401076 <phase_4+0x2e> ; 如果不是，则爆炸
  40106a:       8b 44 24 0c             mov    0xc(%rsp),%eax      ; 将 第二个数的值赋给 eax
  40106e:       83 e8 02                sub    $0x2,%eax           ; eax - 2
  401071:       83 f8 02                cmp    $0x2,%eax           ; 比较 eax 是否为 2
  401074:       76 05                   jbe    40107b <phase_4+0x33> ; 如果小于等于 2，则跳转不爆炸     第一个数<4
  401076:       e8 5e 05 00 00          callq  4015d9 <explode_bomb> ; 爆炸
  40107b:       8b 74 24 0c             mov    0xc(%rsp),%esi      ; 将第一个数的值赋给 esi
  40107f:       bf 05 00 00 00          mov    $0x5,%edi           ; edi = 5
  401084:       e8 87 ff ff ff          callq  401010 <func4>       ; 调用 func4(5,esi)
  401089:       3b 44 24 08             cmp    0x8(%rsp),%eax      ; 比较第二个数与 eax 的值,即func4返回值
  40108d:       74 05                   je     401094 <phase_4+0x4c> ; 如果相等，则跳转
  40108f:       e8 45 05 00 00          callq  4015d9 <explode_bomb>
  401094:       48 83 c4 18             add    $0x18,%rsp
  401098:       c3                      retq





0000000000401010 <func4>:

func(edi,esi)

  401010:       41 54                   push   %r12
  401012:       55                      push   %rbp
  401013:       53                      push   %rbx

  401014:       89 fb                   mov    %edi,%ebx

ebx=edi

  401016:       85 ff                   test   %edi,%edi
  401018:       7e 24                   jle    40103e <func4+0x2e>

if edi<=0,return 0

  40101a:       89 f5                   mov    %esi,%ebp
  40101c:       89 f0                   mov    %esi,%eax

ebp=esi
eax=esi

  40101e:       83 ff 01                cmp    $0x1,%edi
  401021:       74 20                   je     401043 <func4+0x33>

if edi=1,return esi 

  401023:       8d 7f ff                lea    -0x1(%rdi),%edi
  401026:       e8 e5 ff ff ff          callq  401010 <func4>

edi--
func(edi,esi)

  40102b:       44 8d 24 28             lea    (%rax,%rbp,1),%r12d

r12d=eax+ebp

  40102f:       8d 7b fe                lea    -0x2(%rbx),%edi

edi=ebx-2

  401032:       89 ee                   mov    %ebp,%esi

esi=ebp

  401034:       e8 d7 ff ff ff          callq  401010 <func4>

func(edi,esi)

  401039:       44 01 e0                add    %r12d,%eax

eax+=r12d

  40103c:       eb 05                   jmp    401043 <func4+0x33>

return eax

  40103e:       b8 00 00 00 00          mov    $0x0,%eax

eax=0

  401043:       5b                      pop    %rbx
  401044:       5d                      pop    %rbp
  401045:       41 5c                   pop    %r12
  401047:       c3                      retq


