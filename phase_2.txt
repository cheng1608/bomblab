0000000000400f0c <phase_2>:
  400f0c:       55                      push   %rbp           ; 保存调用者的栈帧基指针
  400f0d:       53                      push   %rbx           ; 保存调用者的通用寄存器
  400f0e:       48 83 ec 28             sub    $0x28,%rsp    ; 分配 40 字节的栈空间
  400f12:       48 89 e6                mov    %rsp,%rsi     ; 将栈指针赋值给 %rsi 寄存器
  400f15:       e8 f5 06 00 00          callq  40160f <read_six_numbers>  ; 调用 read_six_numbers 函数
  400f1a:       83 3c 24 00             cmpl   $0x0,(%rsp)  ; 比较栈顶元素和 0 是否相等
  400f1e:       75 07                   jne    400f27 <phase_2+0x1b>  ; 如果不相等，跳转到 400f27
  400f20:       83 7c 24 04 01          cmpl   $0x1,0x4(%rsp)  ; 比较第二个数和 1 是否相等
  400f25:       74 21                   je     400f48 <phase_2+0x3c>  ; 如果相等，跳转到 400f48
  400f27:       e8 ad 06 00 00          callq  4015d9 <explode_bomb>  ; 调用 explode_bomb 函数
  400f2c:       eb 1a                   jmp    400f48 <phase_2+0x3c>  ; 跳转到 400f48

loop_start:
  400f2e:       8b 43 f8                mov    -0x8(%rbx),%eax  ; 将当前元素的前面第二个数移入 %eax
  400f31:       03 43 fc                add    -0x4(%rbx),%eax  ; 将当前元素的前一个数和前第二个数相加
  400f34:       39 03                   cmp    %eax,(%rbx)      ; 比较结果和当前元素是否相等
  400f36:       74 05                   je     400f3d <phase_2+0x31>  ; 如果相等，跳转到 400f3d//不炸
  400f38:       e8 9c 06 00 00          callq  4015d9 <explode_bomb>  ; 
  400f3d:       48 83 c3 04             add    $0x4,%rbx       ; 移动到下一个元素
  400f41:       48 39 eb                cmp    %rbp,%rbx       ; 比较当前元素和结束地址是否相等
  400f44:       75 e8                   jne    400f2e <phase_2+0x22>  ; 如果不相等，跳转到 400f2e//circle
  400f46:       eb 0c                   jmp    400f54 <phase_2+0x48>  ; 跳转到 400f54//accept

  400f48:       48 8d 5c 24 08          lea    0x8(%rsp),%rbx  ; 加载栈顶元素的地址到 %rbx
  400f4d:       48 8d 6c 24 18          lea    0x18(%rsp),%rbp  ; 加载栈帧结尾的地址到 %rbp
  400f52:       eb da                   jmp    400f2e <phase_2+0x22>  ; 跳转到 loop_start

  400f54:       48 83 c4 28             add    $0x28,%rsp     ; 释放栈空间
  400f58:       5b                      pop    %rbx           ; 恢复调用者的通用寄存器
  400f59:       5d                      pop    %rbp           ; 恢复调用者的栈帧基指针
  400f5a:       c3                      retq                      ; 返回

栈顶：
low address:
%rsp+0   0
%rsp+4   1
%rsp+8   1
%rsp+12 2   rbx 
%rsp+16 3
%rsp+20 
high address




000000000040160f <read_six_numbers>:
  40160f:       48 83 ec 18             sub    $0x18,%rsp      ; 分配 24 字节的栈空间
  401613:       48 89 f2                mov    %rsi,%rdx       ; 将第二个参数（指向输入数组的指针）赋值给 %rdx 寄存器
  401616:       48 8d 4e 04             lea    0x4(%rsi),%rcx  ; 计算第二个数字的地址（第一个数字后面的地址）并赋值给 %rcx 寄存器
  40161a:       48 8d 46 14             lea    0x14(%rsi),%rax ; 计算第六个数字的地址并赋值给 %rax 寄存器
  40161e:       48 89 44 24 08          mov    %rax,0x8(%rsp)  ; 将第六个数字的地址保存到栈上
  401623:       48 8d 46 10             lea    0x10(%rsi),%rax ; 计算第五个数字的地址并赋值给 %rax 寄存器
  401627:       48 89 04 24             mov    %rax,(%rsp)     ; 将第五个数字的地址保存到栈上
  40162b:       4c 8d 4e 0c             lea    0xc(%rsi),%r9   ; 计算第四个数字的地址并赋值给 %r9 寄存器
  40162f:       4c 8d 46 08             lea    0x8(%rsi),%r8   ; 计算第三个数字的地址并赋值给 %r8 寄存器
  401633:       be f5 27 40 00          mov    $0x4027f5,%esi  ; 将格式化字符串的地址赋值给 %esi 寄存器
  401638:       b8 00 00 00 00          mov    $0x0,%eax       ; 将 0 赋值给 %eax 寄存器
  40163d:       e8 ee f5 ff ff          callq  400c30 <__isoc99_sscanf@plt>  ; 调用 sscanf 函数解析输入
  401642:       83 f8 05                cmp    $0x5,%eax       ; 比较 sscanf 返回值和 5
  401645:       7f 05                   jg     40164c <read_six_numbers+0x3d>  ; 如果返回值大于 5，跳转到 40164c
  401647:       e8 8d ff ff ff          callq  4015d9 <explode_bomb>  ; 如果返回值小于等于 5，调用 explode_bomb 函数
  40164c:       48 83 c4 18             add    $0x18,%rsp      ; 释放栈空间
  401650:       c3                      retq                      ; 返回


